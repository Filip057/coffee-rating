# Groups App - Application Context

> **Last Updated:** 2025-12-14
> **Owner:** Filip Prudek
> **Status:** Development

---

## Purpose & Responsibility

Manages team/group functionality for collaborative coffee tracking. Enables users to create groups, invite members, and maintain shared coffee libraries.

**Core Responsibility:**
- Group creation and management
- Member invitations via invite codes
- Role-based access control (Owner, Admin, Member)
- Group coffee library management
- Member management (join, leave, promote, remove)

**NOT Responsible For:**
- User authentication (that's `accounts` app)
- Coffee bean catalog (that's `beans` app)
- Group reviews (that's `reviews` app with context='group')
- Purchase tracking (that's `purchases` app)

---

## Models

### **Group**

**Purpose:** Team/group entity for shared coffee tracking and collaboration.

**Fields:**
| Field | Type | Purpose | Business Rule |
|-------|------|---------|---------------|
| `id` | UUIDField (PK) | Unique identifier | Auto-generated |
| `name` | CharField(200) | Group name | Required |
| `description` | TextField | Group description | Optional |
| `is_private` | BooleanField | Visibility setting | Default: True |
| `invite_code` | CharField(16) | Join code | Auto-generated, unique, indexed |
| `owner` | FK(User) | Group owner | Required, CASCADE delete |
| `created_at` | DateTimeField | Creation timestamp | Auto-set |
| `updated_at` | DateTimeField | Last update | Auto-set |

**Relationships:**
- **Belongs To:** User (via `owner`)
- **Has Many:** GroupMembership (via `memberships`)
- **Has Many:** GroupLibraryEntry (via `library_entries`)
- **Has Many:** Review (via `reviews` with context='group')
- **Has Many:** Purchase (via `purchases`)

**Key Methods:**
```python
def save(self, *args, **kwargs):
    """Auto-generates invite_code on first save."""
    if not self.invite_code:
        self.invite_code = secrets.token_urlsafe(12)[:16]
    super().save(*args, **kwargs)

def regenerate_invite_code(self):
    """Generate new invite code (invalidates old one)."""
    self.invite_code = secrets.token_urlsafe(12)[:16]
    self.save(update_fields=['invite_code', 'updated_at'])
    return self.invite_code

def has_member(self, user):
    """Check if user is a member of this group."""
    return self.memberships.filter(user=user).exists()

def get_user_role(self, user):
    """Get user's role in this group (or None if not member)."""
    try:
        return self.memberships.get(user=user).role
    except GroupMembership.DoesNotExist:
        return None

def is_admin(self, user):
    """Check if user is admin or owner."""
    role = self.get_user_role(user)
    return role in [GroupRole.OWNER, GroupRole.ADMIN]
```

**Business Rules:**
1. **Auto Invite Code:** Generated on creation, can be regenerated by admins
2. **Owner Cannot Leave:** Must transfer ownership or delete group
3. **Hard Delete:** Groups are hard deleted (CASCADE deletes memberships, library)

**Indexes:**
- `(owner, created_at)` (for user's owned groups)
- `invite_code` (for join lookups)

---

### **GroupMembership**

**Purpose:** Junction table for user membership in groups with role assignment.

**Fields:**
| Field | Type | Purpose | Business Rule |
|-------|------|---------|---------------|
| `id` | UUIDField (PK) | Unique identifier | Auto-generated |
| `user` | FK(User) | Member user | Required, CASCADE delete |
| `group` | FK(Group) | Parent group | Required, CASCADE delete |
| `role` | CharField(20) | Member role | Default: member |
| `joined_at` | DateTimeField | Join timestamp | Auto-set |

**Enum Choices:**
```python
class GroupRole(models.TextChoices):
    OWNER = 'owner', 'Owner'
    ADMIN = 'admin', 'Admin'
    MEMBER = 'member', 'Member'
```

**Relationships:**
- **Belongs To:** User (via `user`)
- **Belongs To:** Group (via `group`)

**Key Methods:**
```python
def save(self, *args, **kwargs):
    """Enforces owner role for group owner."""
    if self.group.owner_id == self.user_id:
        self.role = GroupRole.OWNER
    super().save(*args, **kwargs)
```

**Business Rules:**
1. **Unique Constraint:** `(user, group)` - one membership per user per group
2. **Owner Role Enforced:** If user is group owner, role is always OWNER
3. **Role Hierarchy:** OWNER > ADMIN > MEMBER

**Indexes:**
- `(group, role)` (for listing by role)
- `(user, joined_at)` (for user's membership history)

---

### **GroupLibraryEntry**

**Purpose:** Shared coffee bean library for a group.

**Fields:**
| Field | Type | Purpose | Business Rule |
|-------|------|---------|---------------|
| `id` | UUIDField (PK) | Unique identifier | Auto-generated |
| `group` | FK(Group) | Parent group | Required, CASCADE delete |
| `coffeebean` | FK(CoffeeBean) | Coffee bean | Required, CASCADE delete |
| `added_by` | FK(User) | Who added it | SET_NULL on delete |
| `added_at` | DateTimeField | Add timestamp | Auto-set |
| `pinned` | BooleanField | Pin to top | Default: False |
| `notes` | TextField | Library notes | Optional |

**Relationships:**
- **Belongs To:** Group (via `group`)
- **Belongs To:** CoffeeBean (via `coffeebean`)
- **Belongs To:** User (via `added_by`)

**Business Rules:**
1. **Unique Constraint:** `(group, coffeebean)` - one entry per bean per group
2. **Ordering:** Pinned first, then by added_at descending

**Indexes:**
- `(group, pinned, added_at)` (for library listing with pinned first)
- `(group, added_at)` (for chronological listing)

---

## API Endpoints

### Group CRUD

| Method | Endpoint | Purpose | Auth | Permissions |
|--------|----------|---------|------|-------------|
| GET | `/api/groups/` | List user's groups | Required | IsAuthenticated |
| POST | `/api/groups/` | Create group | Required | IsAuthenticated |
| GET | `/api/groups/{id}/` | Get group details | Required | IsGroupMember |
| PUT | `/api/groups/{id}/` | Full update | Required | IsGroupAdmin |
| PATCH | `/api/groups/{id}/` | Partial update | Required | IsGroupAdmin |
| DELETE | `/api/groups/{id}/` | Delete group | Required | IsGroupOwner |
| GET | `/api/groups/my/` | List user's groups (alt) | Required | IsAuthenticated |

### Membership Management

| Method | Endpoint | Purpose | Auth | Permissions |
|--------|----------|---------|------|-------------|
| GET | `/api/groups/{id}/members/` | List members | Required | IsGroupMember |
| POST | `/api/groups/{id}/join/` | Join with invite code | Required | IsAuthenticated |
| POST | `/api/groups/{id}/leave/` | Leave group | Required | IsGroupMember |
| POST | `/api/groups/{id}/regenerate_invite/` | New invite code | Required | IsGroupAdmin |
| POST | `/api/groups/{id}/update_member_role/` | Change member role | Required | IsGroupAdmin |
| DELETE | `/api/groups/{id}/remove_member/` | Remove member | Required | IsGroupAdmin |

### Group Library

| Method | Endpoint | Purpose | Auth | Permissions |
|--------|----------|---------|------|-------------|
| GET | `/api/groups/{id}/library/` | Get library | Required | IsGroupMember |
| POST | `/api/groups/{id}/add_to_library/` | Add bean | Required | IsGroupMember |

---

## Business Logic & Workflows

### **Workflow 1: Group Creation**

**Trigger:** POST to `/api/groups/`

**Steps:**
1. Validate required fields (name)
2. Auto-generate invite_code
3. Set owner to current user
4. Create group
5. Create owner membership with OWNER role
6. Return group with invite_code

**Code:**
```python
@transaction.atomic
def perform_create(self, serializer):
    group = serializer.save(owner=self.request.user)

    # Add creator as owner member
    GroupMembership.objects.create(
        user=self.request.user,
        group=group,
        role=GroupRole.OWNER
    )
```

**Important:** Uses `@transaction.atomic` to ensure both group and membership are created.

### **Workflow 2: Join Group**

**Trigger:** POST to `/api/groups/{id}/join/` with invite_code

**Steps:**
1. Verify invite_code matches group's code
2. Check user is not already a member
3. Create membership with MEMBER role
4. Return membership data

**Edge Cases:**
- Invalid invite code: Returns 400
- Already a member: Returns 400
- Non-member can't access group: Returns 404 (queryset filtered)

### **Workflow 3: Leave Group**

**Trigger:** POST to `/api/groups/{id}/leave/`

**Steps:**
1. Check user is not the owner
2. Find and delete membership
3. Return 204 No Content

**Edge Cases:**
- Owner tries to leave: Returns 400 with "owner cannot leave" message
- Not a member: Returns 400

### **Workflow 4: Role Management**

**Trigger:** POST to `/api/groups/{id}/update_member_role/`

**Steps:**
1. Verify requester is admin/owner
2. Validate user_id and role in request
3. Check target user is not the owner
4. Update membership role
5. Return updated membership

**Allowed Role Changes:**
- member -> admin (promotion)
- admin -> member (demotion)
- Cannot change owner's role

---

## Permissions & Security

**Permission Classes:**
```python
class IsGroupAdmin(BasePermission):
    """User must be group admin or owner."""
    def has_object_permission(self, request, view, obj):
        return obj.is_admin(request.user)

class IsGroupMember(BasePermission):
    """User must be a member of the group."""
    def has_object_permission(self, request, view, obj):
        return obj.has_member(request.user)

class IsGroupOwner(BasePermission):
    """User must be the group owner."""
    def has_object_permission(self, request, view, obj):
        return obj.owner == request.user
```

**Access Rules:**
| Action | Who Can Do It |
|--------|---------------|
| List groups | Members only (via queryset filter) |
| View group | Members only |
| Update group | Admin or Owner |
| Delete group | Owner only |
| Manage members | Admin or Owner |
| View library | Members |
| Add to library | Members |
| Regenerate invite | Admin or Owner |

**Security Considerations:**
- Invite codes are 16 characters of URL-safe random bytes
- Non-members see 404 (not 403) to hide group existence
- Owner role cannot be changed except by ownership transfer (not implemented)
- QuerySet is filtered by membership to prevent enumeration

---

## Testing Strategy

**What to Test:**
1. Group CRUD operations
2. Membership management (join, leave, roles)
3. Permission enforcement at each role level
4. Library operations
5. Edge cases (owner leaving, duplicate membership)

**Test Coverage:** 40+ test cases in `apps/groups/tests/test_api.py`

**Critical Test Cases:**
```python
def test_leave_group_as_owner_forbidden(self, authenticated_client, group):
    """Owner cannot leave their own group."""
    url = reverse('groups:group-leave', args=[group.id])
    response = authenticated_client.post(url)

    assert response.status_code == 400
    assert 'owner cannot leave' in response.data['error']

def test_owner_role_enforced(self, group, group_owner):
    """Owner membership always has owner role."""
    membership = GroupMembership.objects.get(user=group_owner, group=group)
    membership.role = GroupRole.MEMBER  # Try to change
    membership.save()

    membership.refresh_from_db()
    assert membership.role == GroupRole.OWNER  # Reset to owner
```

---

## Dependencies & Relationships

**This App Uses:**
- `accounts.User` - For owner and member references
- `beans.CoffeeBean` - For library entries

**Used By:**
- `reviews` - Group reviews (context='group')
- `purchases` - Group purchases
- `analytics` - Group consumption statistics

**External Services:**
- None

---

## Common Patterns

**Pattern 1: Membership-Filtered QuerySet**
```python
def get_queryset(self):
    """Return only groups where user is a member."""
    user = self.request.user
    return Group.objects.filter(
        memberships__user=user
    ).select_related('owner').prefetch_related('memberships').distinct()
```

**When to Use:** All group list/retrieve operations

**Pattern 2: Admin Permission Check**
```python
if not group.is_admin(request.user):
    from rest_framework.exceptions import PermissionDenied
    raise PermissionDenied("Only admins can perform this action")
```

**When to Use:** Admin-only actions within action methods

**Pattern 3: Atomic Group Creation**
```python
@transaction.atomic
def perform_create(self, serializer):
    group = serializer.save(owner=self.request.user)
    GroupMembership.objects.create(
        user=self.request.user,
        group=group,
        role=GroupRole.OWNER
    )
```

**When to Use:** Creating group with owner membership

---

## Gotchas & Known Issues

**Issue 1: Non-Members Can't Access Join Endpoint**
- **Symptom:** New users get 404 when trying to join
- **Cause:** QuerySet filtered by membership, so non-members can't see any group
- **Workaround:** Share group ID with invite code; use direct URL
- **Status:** By design - consider separate public join endpoint

**Issue 2: No Ownership Transfer**
- **Symptom:** Owner can't leave or transfer ownership
- **Cause:** Feature not implemented
- **Workaround:** Delete and recreate group
- **Status:** TODO - Implement ownership transfer

**Issue 3: Hard Delete of Groups**
- **Symptom:** Deleting group removes all memberships, library, associated data
- **Cause:** CASCADE delete on foreign keys
- **Workaround:** None - this is intentional
- **Status:** By design

---

## Future Enhancements

**Planned:**
- [ ] Ownership transfer functionality
- [ ] Public join endpoint for invite codes
- [ ] Group activity feed
- [ ] Member invite notifications

**Ideas:**
- [ ] Group statistics dashboard
- [ ] Invite link expiration
- [ ] Member approval workflow for private groups
- [ ] Group chat/comments

**Won't Do (and Why):**
- Public group directory - Out of scope, groups are for known teams
- Nested groups/sub-groups - Too complex for MVP

---

## Related Documentation

- [API Reference](../API.md#groups-endpoints)
- [Database Schema](../DATABASE.md)
- Other App Contexts: [accounts](./accounts.md), [beans](./beans.md), [reviews](./reviews.md)

---

## Notes for Developers

> **Why Membership-Filtered QuerySet?**
> Filtering by membership in the queryset provides automatic access control. Non-members get 404 instead of 403, which prevents group enumeration attacks.

> **Why Owner Role is Enforced in Model?**
> The save() method ensures the group owner always has OWNER role, even if someone tries to change it. This is a safety mechanism.

> **Why Hard Delete?**
> Groups represent temporary or project-based teams. When a group is deleted, all associated data should go with it. Historical data is preserved in purchases/reviews with foreign keys.

---

## AI Assistant Context

**When modifying this app, ALWAYS remember:**

1. **NEVER allow owner to leave without transfer/delete**
   - Owner must transfer ownership OR delete the group
   - This prevents orphaned groups

2. **ALWAYS use transaction.atomic for group creation**
   - Group and owner membership must be created together
   - Failure in either should roll back both

3. **ALWAYS filter queryset by membership**
   - Non-members should see 404, not 403
   - Prevents group enumeration

4. **NEVER change owner's role via update_member_role**
   - Owner role is protected
   - Return 400 if attempted

**Typical Prompts:**

```
"Add ownership transfer"
-> Remember:
1. Only owner can transfer
2. New owner must be existing member
3. Update group.owner and membership roles atomically
4. Old owner becomes admin or member

"Add public join endpoint"
-> Consider:
1. New endpoint outside membership-filtered queryset
2. Rate limiting to prevent code brute-forcing
3. Return minimal group info on success

"Add invite link expiration"
-> Check:
1. Add expires_at field to Group or separate InviteLink model
2. Validate expiration in join endpoint
3. Allow regenerate to extend expiration
```
