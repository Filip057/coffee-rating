# Groups App - Application Context

> **Last Updated:** 2025-12-14
> **Owner:** Filip Prudek
> **Status:** Development

---

## Purpose & Responsibility

Manages team/group functionality for collaborative coffee tracking. Enables users to create groups, invite members, and maintain shared coffee libraries.

**Core Responsibility:**
- Group creation and management
- Member invitations via invite codes
- Role-based access control (Owner, Admin, Member)
- Group coffee library management
- Member management (join, leave, promote, remove)

**NOT Responsible For:**
- User authentication (that's `accounts` app)
- Coffee bean catalog (that's `beans` app)
- Group reviews (that's `reviews` app with context='group')
- Purchase tracking (that's `purchases` app)

---

## Models

### **Group**

**Purpose:** Team/group entity for shared coffee tracking and collaboration.

**Fields:**
| Field | Type | Purpose | Business Rule |
|-------|------|---------|---------------|
| `id` | UUIDField (PK) | Unique identifier | Auto-generated |
| `name` | CharField(200) | Group name | Required |
| `description` | TextField | Group description | Optional |
| `is_private` | BooleanField | Visibility setting | Default: True |
| `invite_code` | CharField(16) | Join code | Auto-generated, unique, indexed |
| `owner` | FK(User) | Group owner | Required, CASCADE delete |
| `created_at` | DateTimeField | Creation timestamp | Auto-set |
| `updated_at` | DateTimeField | Last update | Auto-set |

**Relationships:**
- **Belongs To:** User (via `owner`)
- **Has Many:** GroupMembership (via `memberships`)
- **Has Many:** GroupLibraryEntry (via `library_entries`)
- **Has Many:** Review (via `reviews` with context='group')
- **Has Many:** Purchase (via `purchases`)

**Domain Query Methods:**
```python
def has_member(self, user):
    """Check if user is a member of this group."""
    return self.memberships.filter(user=user).exists()

def get_user_role(self, user):
    """Get user's role in this group (or None if not member)."""
    try:
        return self.memberships.get(user=user).role
    except GroupMembership.DoesNotExist:
        return None

def is_admin(self, user):
    """Check if user is admin or owner."""
    role = self.get_user_role(user)
    return role in [GroupRole.OWNER, GroupRole.ADMIN]
```

**Note:** Business logic (invite code generation, group creation) has been moved to the services layer. See [Services Layer Architecture](#services-layer-architecture) below.

**Business Rules:**
1. **Auto Invite Code:** Generated on creation, can be regenerated by admins
2. **Owner Cannot Leave:** Must transfer ownership or delete group
3. **Hard Delete:** Groups are hard deleted (CASCADE deletes memberships, library)

**Indexes:**
- `(owner, created_at)` (for user's owned groups)
- `invite_code` (for join lookups)

---

### **GroupMembership**

**Purpose:** Junction table for user membership in groups with role assignment.

**Fields:**
| Field | Type | Purpose | Business Rule |
|-------|------|---------|---------------|
| `id` | UUIDField (PK) | Unique identifier | Auto-generated |
| `user` | FK(User) | Member user | Required, CASCADE delete |
| `group` | FK(Group) | Parent group | Required, CASCADE delete |
| `role` | CharField(20) | Member role | Default: member |
| `joined_at` | DateTimeField | Join timestamp | Auto-set |

**Enum Choices:**
```python
class GroupRole(models.TextChoices):
    OWNER = 'owner', 'Owner'
    ADMIN = 'admin', 'Admin'
    MEMBER = 'member', 'Member'
```

**Relationships:**
- **Belongs To:** User (via `user`)
- **Belongs To:** Group (via `group`)

**Note:** Owner role assignment has been moved to the services layer. See [Services Layer Architecture](#services-layer-architecture) below.

**Business Rules:**
1. **Unique Constraint:** `(user, group)` - one membership per user per group
2. **Owner Role Enforced:** If user is group owner, role is always OWNER
3. **Role Hierarchy:** OWNER > ADMIN > MEMBER

**Indexes:**
- `(group, role)` (for listing by role)
- `(user, joined_at)` (for user's membership history)

---

### **GroupLibraryEntry**

**Purpose:** Shared coffee bean library for a group.

**Fields:**
| Field | Type | Purpose | Business Rule |
|-------|------|---------|---------------|
| `id` | UUIDField (PK) | Unique identifier | Auto-generated |
| `group` | FK(Group) | Parent group | Required, CASCADE delete |
| `coffeebean` | FK(CoffeeBean) | Coffee bean | Required, CASCADE delete |
| `added_by` | FK(User) | Who added it | SET_NULL on delete |
| `added_at` | DateTimeField | Add timestamp | Auto-set |
| `pinned` | BooleanField | Pin to top | Default: False |
| `notes` | TextField | Library notes | Optional |

**Relationships:**
- **Belongs To:** Group (via `group`)
- **Belongs To:** CoffeeBean (via `coffeebean`)
- **Belongs To:** User (via `added_by`)

**Business Rules:**
1. **Unique Constraint:** `(group, coffeebean)` - one entry per bean per group
2. **Ordering:** Pinned first, then by added_at descending

**Indexes:**
- `(group, pinned, added_at)` (for library listing with pinned first)
- `(group, added_at)` (for chronological listing)

---

## Services Layer Architecture

> **Refactored:** December 2024 - Business logic extracted from models and views into dedicated services layer following DRF best practices.

### **Overview**

The groups app implements a comprehensive services layer that centralizes all business logic, providing:

- **Transaction Safety**: All state-changing operations wrapped in `@transaction.atomic`
- **Concurrency Protection**: Row-level locking with `select_for_update()` for critical operations
- **Domain Exceptions**: Specific error types for clear error handling
- **Type Safety**: Full type hints throughout
- **Separation of Concerns**: Views are thin HTTP handlers, services contain business logic

### **Service Modules**

All services located in `apps/groups/services/`:

| Module | Purpose | Key Functions |
|--------|---------|---------------|
| `group_management.py` | Group CRUD operations | create_group, get_group_by_id, update_group, delete_group |
| `membership_management.py` | Member operations | join_group, leave_group, remove_member, get_group_members |
| `role_management.py` | Role changes | update_member_role |
| `invite_management.py` | Invite code operations | regenerate_invite_code, validate_invite_code |
| `library_management.py` | Group library | add_to_library, remove_from_library, pin/unpin, get_group_library |
| `exceptions.py` | Domain exceptions | GroupNotFoundError, AlreadyMemberError, etc. |

### **Domain Exceptions**

```python
# Base exception
class GroupsServiceError(Exception):
    """Base exception for all groups service errors."""

# Specific exceptions
class GroupNotFoundError(GroupsServiceError)
class InvalidInviteCodeError(GroupsServiceError)
class AlreadyMemberError(GroupsServiceError)
class NotMemberError(GroupsServiceError)
class InsufficientPermissionsError(GroupsServiceError)
class CannotLeaveAsOwnerError(GroupsServiceError)
class CannotChangeOwnerRoleError(GroupsServiceError)
class CannotRemoveSelfError(GroupsServiceError)
class BeanNotFoundError(GroupsServiceError)
class DuplicateLibraryEntryError(GroupsServiceError)
class LibraryEntryNotFoundError(GroupsServiceError)
```

### **Transaction Safety Patterns**

All state-changing operations use `@transaction.atomic` to ensure data consistency:

**Pattern 1: Atomic Group Creation**
```python
@transaction.atomic
def create_group(
    *,
    name: str,
    owner: User,
    description: str = '',
    is_private: bool = True,
    max_retries: int = 5
) -> Group:
    """Create a new group and add the creator as owner."""
    # Generate unique invite code with retry logic
    for attempt in range(max_retries):
        invite_code = secrets.token_urlsafe(12)[:16]
        try:
            group = Group.objects.create(
                name=name,
                owner=owner,
                description=description,
                is_private=is_private,
                invite_code=invite_code
            )
            # Create owner membership atomically
            GroupMembership.objects.create(
                user=owner,
                group=group,
                role=GroupRole.OWNER
            )
            return group
        except IntegrityError:
            if attempt == max_retries - 1:
                raise RuntimeError("Failed to generate unique invite code")
            continue
```

**Key Features:**
- Both Group and GroupMembership created in single transaction
- Invite code uniqueness guaranteed with retry logic
- Either both succeed or both roll back

**Pattern 2: Atomic Deletion**
```python
@transaction.atomic
def delete_group(
    *,
    group_id: UUID,
    user: User
) -> None:
    """Delete a group (owner only)."""
    try:
        group = (
            Group.objects
            .select_for_update()  # Lock during deletion
            .get(id=group_id)
        )
    except Group.DoesNotExist:
        raise GroupNotFoundError(...)

    if group.owner != user:
        raise InsufficientPermissionsError("Only owner can delete")

    group.delete()  # CASCADE deletes memberships, library
```

### **Concurrency Protection Strategies**

Critical operations use `select_for_update()` to prevent race conditions:

**Strategy 1: Preventing Duplicate Memberships**
```python
@transaction.atomic
def join_group(
    *,
    group_id: UUID,
    user: User,
    invite_code: str
) -> GroupMembership:
    """Join a group using an invite code."""
    # Lock the group to prevent concurrent joins
    try:
        group = (
            Group.objects
            .select_for_update()  # ← Row-level lock
            .get(id=group_id)
        )
    except Group.DoesNotExist:
        raise GroupNotFoundError(...)

    # Verify invite code
    if group.invite_code != invite_code:
        raise InvalidInviteCodeError("Invalid invite code")

    # Check if already a member (defensive)
    if group.has_member(user):
        raise AlreadyMemberError(...)

    # Create membership
    try:
        membership = GroupMembership.objects.create(
            user=user,
            group=group,
            role=GroupRole.MEMBER
        )
    except IntegrityError:
        # Database unique constraint caught duplicate
        raise AlreadyMemberError(...)

    return membership
```

**Why This Works:**
- `select_for_update()` locks the group row until transaction commits
- Multiple concurrent join requests will serialize
- Database unique constraint provides additional safety net
- No duplicate memberships possible

**Strategy 2: Preventing Lost Updates**
```python
@transaction.atomic
def update_member_role(
    *,
    group_id: UUID,
    user_id: UUID,
    new_role: str,
    updated_by: User
) -> GroupMembership:
    """Update a member's role (admin only)."""
    # ... validation ...

    # Lock the membership row to prevent concurrent updates
    try:
        membership = (
            GroupMembership.objects
            .select_for_update()  # ← Row-level lock
            .get(group=group, user_id=user_id)
        )
    except GroupMembership.DoesNotExist:
        raise NotMemberError(...)

    # Cannot change owner's role
    if membership.role == GroupRole.OWNER:
        raise CannotChangeOwnerRoleError(...)

    # Update role
    membership.role = new_role
    membership.save(update_fields=['role'])

    return membership
```

**Why This Works:**
- `select_for_update()` locks the membership row
- Concurrent role updates will serialize
- No lost updates - all changes are applied correctly

**Strategy 3: Invite Code Uniqueness**
```python
@transaction.atomic
def regenerate_invite_code(
    *,
    group_id: UUID,
    user: User,
    max_retries: int = 5
) -> str:
    """Regenerate a group's invite code (admin only)."""
    # Lock the group
    try:
        group = (
            Group.objects
            .select_for_update()
            .get(id=group_id)
        )
    except Group.DoesNotExist:
        raise GroupNotFoundError(...)

    # Check permissions
    if not group.is_admin(user):
        raise InsufficientPermissionsError(...)

    # Generate unique code with retry logic
    for attempt in range(max_retries):
        new_code = secrets.token_urlsafe(12)[:16]
        try:
            group.invite_code = new_code
            group.save(update_fields=['invite_code', 'updated_at'])
            return new_code
        except IntegrityError:
            # Collision detected, retry
            if attempt == max_retries - 1:
                raise RuntimeError("Failed to generate unique invite code")
            continue
```

**Why This Works:**
- Retry logic handles rare collisions
- Database unique constraint provides safety
- Maximum 5 attempts before failing
- Probability of collision is astronomically low (2^96 possible codes)

### **Service Usage Examples**

**Example 1: Creating a Group (View Layer)**
```python
from apps.groups.services import create_group, GroupsServiceError

class GroupViewSet(viewsets.ModelViewSet):
    @transaction.atomic
    def perform_create(self, serializer):
        """Create group using service."""
        try:
            group = create_group(
                name=serializer.validated_data['name'],
                owner=self.request.user,
                description=serializer.validated_data.get('description', ''),
                is_private=serializer.validated_data.get('is_private', True)
            )
        except GroupsServiceError as e:
            from rest_framework.exceptions import ValidationError
            raise ValidationError(str(e))

        # Return serialized group
        serializer.instance = group
```

**Example 2: Joining a Group (Action Method)**
```python
from apps.groups.services import join_group
from apps.groups.services.exceptions import InvalidInviteCodeError, AlreadyMemberError

@action(detail=True, methods=['post'])
def join(self, request, pk=None):
    """Join a group using invite code."""
    serializer = JoinGroupSerializer(data=request.data)
    serializer.is_valid(raise_exception=True)

    try:
        membership = join_group(
            group_id=pk,
            user=request.user,
            invite_code=serializer.validated_data['invite_code']
        )
    except (InvalidInviteCodeError, AlreadyMemberError) as e:
        return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

    output_serializer = GroupMemberSerializer(membership)
    return Response(output_serializer.data, status=status.HTTP_201_CREATED)
```

**Example 3: Managing Roles (Action Method)**
```python
from apps.groups.services import update_member_role
from apps.groups.services.exceptions import (
    InsufficientPermissionsError,
    CannotChangeOwnerRoleError
)

@action(detail=True, methods=['post'], permission_classes=[IsGroupAdmin])
def update_member_role(self, request, pk=None):
    """Update a member's role."""
    serializer = UpdateMemberRoleSerializer(data=request.data)
    serializer.is_valid(raise_exception=True)

    try:
        membership = services.update_member_role(
            group_id=pk,
            user_id=serializer.validated_data['user_id'],
            new_role=serializer.validated_data['role'],
            updated_by=request.user
        )
    except InsufficientPermissionsError as e:
        return Response({'error': str(e)}, status=status.HTTP_403_FORBIDDEN)
    except CannotChangeOwnerRoleError as e:
        return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

    output_serializer = GroupMemberSerializer(membership)
    return Response(output_serializer.data)
```

### **Benefits of Services Layer**

**Before Refactoring:**
- Business logic scattered across views and models
- No transaction safety (87.5% of operations)
- Zero concurrency protection
- Race conditions possible under load
- ~378 lines of code in views.py with mixed concerns

**After Refactoring:**
- All business logic centralized in services
- 100% transaction safety for state-changing operations
- Full concurrency protection with row-level locking
- No race conditions possible
- Views reduced to 261 lines (31% reduction)
- Views are thin HTTP handlers only
- Easier to test (services are pure functions)
- Better type safety with full type hints

### **Testing Services**

**Unit Test Example:**
```python
from apps.groups.services import create_group, join_group
from apps.groups.services.exceptions import AlreadyMemberError

def test_cannot_join_group_twice(user):
    """User cannot join same group twice."""
    # Create group
    group = create_group(name="Test", owner=user)

    # Try to join as owner (already a member)
    with pytest.raises(AlreadyMemberError):
        join_group(
            group_id=group.id,
            user=user,
            invite_code=group.invite_code
        )
```

**Concurrency Test Example:**
```python
import threading
from django.db import transaction

def test_concurrent_join_prevented(group, users):
    """Multiple concurrent joins don't create duplicates."""
    results = []
    errors = []

    def join_as_user(user):
        try:
            membership = join_group(
                group_id=group.id,
                user=user,
                invite_code=group.invite_code
            )
            results.append(membership)
        except AlreadyMemberError:
            errors.append(user)

    # Spawn 10 threads trying to join simultaneously
    threads = [
        threading.Thread(target=join_as_user, args=(user,))
        for user in users
    ]

    for thread in threads:
        thread.start()

    for thread in threads:
        thread.join()

    # Verify: each user joined exactly once
    assert len(results) == len(users)
    assert len(errors) == 0

    # Verify: no duplicate memberships in database
    memberships = GroupMembership.objects.filter(group=group)
    assert memberships.count() == len(users) + 1  # +1 for owner
```

---

## API Endpoints

### Group CRUD

| Method | Endpoint | Purpose | Auth | Permissions |
|--------|----------|---------|------|-------------|
| GET | `/api/groups/` | List user's groups | Required | IsAuthenticated |
| POST | `/api/groups/` | Create group | Required | IsAuthenticated |
| GET | `/api/groups/{id}/` | Get group details | Required | IsGroupMember |
| PUT | `/api/groups/{id}/` | Full update | Required | IsGroupAdmin |
| PATCH | `/api/groups/{id}/` | Partial update | Required | IsGroupAdmin |
| DELETE | `/api/groups/{id}/` | Delete group | Required | IsGroupOwner |
| GET | `/api/groups/my/` | List user's groups (alt) | Required | IsAuthenticated |

### Membership Management

| Method | Endpoint | Purpose | Auth | Permissions |
|--------|----------|---------|------|-------------|
| GET | `/api/groups/{id}/members/` | List members | Required | IsGroupMember |
| POST | `/api/groups/{id}/join/` | Join with invite code | Required | IsAuthenticated |
| POST | `/api/groups/{id}/leave/` | Leave group | Required | IsGroupMember |
| POST | `/api/groups/{id}/regenerate_invite/` | New invite code | Required | IsGroupAdmin |
| POST | `/api/groups/{id}/update_member_role/` | Change member role | Required | IsGroupAdmin |
| DELETE | `/api/groups/{id}/remove_member/` | Remove member | Required | IsGroupAdmin |

### Group Library

| Method | Endpoint | Purpose | Auth | Permissions |
|--------|----------|---------|------|-------------|
| GET | `/api/groups/{id}/library/` | Get library | Required | IsGroupMember |
| POST | `/api/groups/{id}/add_to_library/` | Add bean | Required | IsGroupMember |

---

## Business Logic & Workflows

### **Workflow 1: Group Creation**

**Trigger:** POST to `/api/groups/`

**Steps:**
1. Validate required fields (name)
2. Auto-generate invite_code
3. Set owner to current user
4. Create group
5. Create owner membership with OWNER role
6. Return group with invite_code

**Code:**
```python
@transaction.atomic
def perform_create(self, serializer):
    group = serializer.save(owner=self.request.user)

    # Add creator as owner member
    GroupMembership.objects.create(
        user=self.request.user,
        group=group,
        role=GroupRole.OWNER
    )
```

**Important:** Uses `@transaction.atomic` to ensure both group and membership are created.

### **Workflow 2: Join Group**

**Trigger:** POST to `/api/groups/{id}/join/` with invite_code

**Steps:**
1. Verify invite_code matches group's code
2. Check user is not already a member
3. Create membership with MEMBER role
4. Return membership data

**Edge Cases:**
- Invalid invite code: Returns 400
- Already a member: Returns 400
- Non-member can't access group: Returns 404 (queryset filtered)

### **Workflow 3: Leave Group**

**Trigger:** POST to `/api/groups/{id}/leave/`

**Steps:**
1. Check user is not the owner
2. Find and delete membership
3. Return 204 No Content

**Edge Cases:**
- Owner tries to leave: Returns 400 with "owner cannot leave" message
- Not a member: Returns 400

### **Workflow 4: Role Management**

**Trigger:** POST to `/api/groups/{id}/update_member_role/`

**Steps:**
1. Verify requester is admin/owner
2. Validate user_id and role in request
3. Check target user is not the owner
4. Update membership role
5. Return updated membership

**Allowed Role Changes:**
- member -> admin (promotion)
- admin -> member (demotion)
- Cannot change owner's role

---

## Permissions & Security

**Permission Classes:**
```python
class IsGroupAdmin(BasePermission):
    """User must be group admin or owner."""
    def has_object_permission(self, request, view, obj):
        return obj.is_admin(request.user)

class IsGroupMember(BasePermission):
    """User must be a member of the group."""
    def has_object_permission(self, request, view, obj):
        return obj.has_member(request.user)

class IsGroupOwner(BasePermission):
    """User must be the group owner."""
    def has_object_permission(self, request, view, obj):
        return obj.owner == request.user
```

**Access Rules:**
| Action | Who Can Do It |
|--------|---------------|
| List groups | Members only (via queryset filter) |
| View group | Members only |
| Update group | Admin or Owner |
| Delete group | Owner only |
| Manage members | Admin or Owner |
| View library | Members |
| Add to library | Members |
| Regenerate invite | Admin or Owner |

**Security Considerations:**
- Invite codes are 16 characters of URL-safe random bytes
- Non-members see 404 (not 403) to hide group existence
- Owner role cannot be changed except by ownership transfer (not implemented)
- QuerySet is filtered by membership to prevent enumeration

---

## Testing Strategy

**What to Test:**
1. Group CRUD operations
2. Membership management (join, leave, roles)
3. Permission enforcement at each role level
4. Library operations
5. Edge cases (owner leaving, duplicate membership)

**Test Coverage:** 40+ test cases in `apps/groups/tests/test_api.py`

**Critical Test Cases:**
```python
def test_leave_group_as_owner_forbidden(self, authenticated_client, group):
    """Owner cannot leave their own group."""
    url = reverse('groups:group-leave', args=[group.id])
    response = authenticated_client.post(url)

    assert response.status_code == 400
    assert 'owner cannot leave' in response.data['error']

def test_owner_role_enforced(self, group, group_owner):
    """Owner membership always has owner role."""
    membership = GroupMembership.objects.get(user=group_owner, group=group)
    membership.role = GroupRole.MEMBER  # Try to change
    membership.save()

    membership.refresh_from_db()
    assert membership.role == GroupRole.OWNER  # Reset to owner
```

---

## Dependencies & Relationships

**This App Uses:**
- `accounts.User` - For owner and member references
- `beans.CoffeeBean` - For library entries

**Used By:**
- `reviews` - Group reviews (context='group')
- `purchases` - Group purchases
- `analytics` - Group consumption statistics

**External Services:**
- None

---

## Common Patterns

**Pattern 1: Membership-Filtered QuerySet**
```python
def get_queryset(self):
    """Return only groups where user is a member."""
    user = self.request.user
    return Group.objects.filter(
        memberships__user=user
    ).select_related('owner').prefetch_related('memberships').distinct()
```

**When to Use:** All group list/retrieve operations

**Pattern 2: Admin Permission Check**
```python
if not group.is_admin(request.user):
    from rest_framework.exceptions import PermissionDenied
    raise PermissionDenied("Only admins can perform this action")
```

**When to Use:** Admin-only actions within action methods

**Pattern 3: Atomic Group Creation**
```python
@transaction.atomic
def perform_create(self, serializer):
    group = serializer.save(owner=self.request.user)
    GroupMembership.objects.create(
        user=self.request.user,
        group=group,
        role=GroupRole.OWNER
    )
```

**When to Use:** Creating group with owner membership

---

## Gotchas & Known Issues

**Issue 1: Non-Members Can't Access Join Endpoint**
- **Symptom:** New users get 404 when trying to join
- **Cause:** QuerySet filtered by membership, so non-members can't see any group
- **Workaround:** Share group ID with invite code; use direct URL
- **Status:** By design - consider separate public join endpoint

**Issue 2: No Ownership Transfer**
- **Symptom:** Owner can't leave or transfer ownership
- **Cause:** Feature not implemented
- **Workaround:** Delete and recreate group
- **Status:** TODO - Implement ownership transfer

**Issue 3: Hard Delete of Groups**
- **Symptom:** Deleting group removes all memberships, library, associated data
- **Cause:** CASCADE delete on foreign keys
- **Workaround:** None - this is intentional
- **Status:** By design

---

## Future Enhancements

**Planned:**
- [ ] Ownership transfer functionality
- [ ] Public join endpoint for invite codes
- [ ] Group activity feed
- [ ] Member invite notifications

**Ideas:**
- [ ] Group statistics dashboard
- [ ] Invite link expiration
- [ ] Member approval workflow for private groups
- [ ] Group chat/comments

**Won't Do (and Why):**
- Public group directory - Out of scope, groups are for known teams
- Nested groups/sub-groups - Too complex for MVP

---

## Related Documentation

- [API Reference](../API.md#groups-endpoints)
- [Database Schema](../DATABASE.md)
- Other App Contexts: [accounts](./accounts.md), [beans](./beans.md), [reviews](./reviews.md)

---

## Notes for Developers

> **Why Membership-Filtered QuerySet?**
> Filtering by membership in the queryset provides automatic access control. Non-members get 404 instead of 403, which prevents group enumeration attacks.

> **Why Owner Role is Enforced in Model?**
> The save() method ensures the group owner always has OWNER role, even if someone tries to change it. This is a safety mechanism.

> **Why Hard Delete?**
> Groups represent temporary or project-based teams. When a group is deleted, all associated data should go with it. Historical data is preserved in purchases/reviews with foreign keys.

---

## AI Assistant Context

**When modifying this app, ALWAYS remember:**

1. **NEVER allow owner to leave without transfer/delete**
   - Owner must transfer ownership OR delete the group
   - This prevents orphaned groups

2. **ALWAYS use transaction.atomic for group creation**
   - Group and owner membership must be created together
   - Failure in either should roll back both

3. **ALWAYS filter queryset by membership**
   - Non-members should see 404, not 403
   - Prevents group enumeration

4. **NEVER change owner's role via update_member_role**
   - Owner role is protected
   - Return 400 if attempted

**Typical Prompts:**

```
"Add ownership transfer"
-> Remember:
1. Only owner can transfer
2. New owner must be existing member
3. Update group.owner and membership roles atomically
4. Old owner becomes admin or member

"Add public join endpoint"
-> Consider:
1. New endpoint outside membership-filtered queryset
2. Rate limiting to prevent code brute-forcing
3. Return minimal group info on success

"Add invite link expiration"
-> Check:
1. Add expires_at field to Group or separate InviteLink model
2. Validate expiration in join endpoint
3. Allow regenerate to extend expiration
```
